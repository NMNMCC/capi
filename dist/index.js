#!/usr/bin/env node
import './sourcemap-register.cjs';var e={};var t={};function __nccwpck_require__(r){var s=t[r];if(s!==undefined){return s.exports}var n=t[r]={exports:{}};var i=true;try{e[r](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete t[r]}return n.exports}(()=>{var e=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;var t;__nccwpck_require__.t=function(r,s){if(s&1)r=this(r);if(s&8)return r;if(typeof r==="object"&&r){if(s&4&&r.__esModule)return r;if(s&16&&typeof r.then==="function")return r}var n=Object.create(null);__nccwpck_require__.r(n);var i={};t=t||[null,e({}),e([]),e(e)];for(var o=s&2&&r;typeof o=="object"&&!~t.indexOf(o);o=e(o)){Object.getOwnPropertyNames(o).forEach((e=>i[e]=()=>r[e]))}i["default"]=()=>r;__nccwpck_require__.d(n,i);return n}})();(()=>{__nccwpck_require__.d=(e,t)=>{for(var r in t){if(__nccwpck_require__.o(t,r)&&!__nccwpck_require__.o(e,r)){Object.defineProperty(e,r,{enumerable:true,get:t[r]})}}}})();(()=>{__nccwpck_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();(()=>{__nccwpck_require__.r=e=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})}})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var r={};const s=require("http");const n=require("http2");const i=require("stream");const o=require("crypto");var a=class extends Error{static name="RequestError";constructor(e,t){super(e,t)}};var toRequestError=e=>{if(e instanceof a){return e}return new a(e.message,{cause:e})};var c=global.Request;var l=class extends c{constructor(e,t){if(typeof e==="object"&&h in e){e=e[h]()}if(typeof t?.body?.getReader!=="undefined"){t.duplex??="half"}super(e,t)}};var newRequestFromIncoming=(e,t,r,s)=>{const n=[];const o=r.rawHeaders;for(let e=0;e<o.length;e+=2){const{[e]:t,[e+1]:r}=o;if(t.charCodeAt(0)!==58){n.push([t,r])}}const a={method:e,headers:n,signal:s.signal};if(e==="TRACE"){a.method="GET";const e=new l(t,a);Object.defineProperty(e,"method",{get(){return"TRACE"}});return e}if(!(e==="GET"||e==="HEAD")){if("rawBody"in r&&r.rawBody instanceof Buffer){a.body=new ReadableStream({start(e){e.enqueue(r.rawBody);e.close()}})}else{a.body=i.Readable.toWeb(r)}}return new l(t,a)};var h=Symbol("getRequestCache");var u=Symbol("requestCache");var d=Symbol("incomingKey");var f=Symbol("urlKey");var p=Symbol("abortControllerKey");var b=Symbol("getAbortController");var g={get method(){return this[d].method||"GET"},get url(){return this[f]},[b](){this[h]();return this[p]},[h](){this[p]||=new AbortController;return this[u]||=newRequestFromIncoming(this.method,this[f],this[d],this[p])}};["body","bodyUsed","cache","credentials","destination","headers","integrity","mode","redirect","referrer","referrerPolicy","signal","keepalive"].forEach((e=>{Object.defineProperty(g,e,{get(){return this[h]()[e]}})}));["arrayBuffer","blob","clone","formData","json","text"].forEach((e=>{Object.defineProperty(g,e,{value:function(){return this[h]()[e]()}})}));Object.setPrototypeOf(g,l.prototype);var newRequest=(e,t)=>{const r=Object.create(g);r[d]=e;const s=e.url||"";if(s[0]!=="/"&&(s.startsWith("http://")||s.startsWith("https://"))){if(e instanceof n.Http2ServerRequest){throw new a("Absolute URL for :path is not allowed in HTTP/2")}try{const e=new URL(s);r[f]=e.href}catch(e){throw new a("Invalid absolute URL",{cause:e})}return r}const i=(e instanceof n.Http2ServerRequest?e.authority:e.headers.host)||t;if(!i){throw new a("Missing host header")}let o;if(e instanceof n.Http2ServerRequest){o=e.scheme;if(!(o==="http"||o==="https")){throw new a("Unsupported scheme")}}else{o=e.socket&&e.socket.encrypted?"https":"http"}const c=new URL(`${o}://${i}${s}`);if(c.hostname.length!==i.length&&c.hostname!==i.replace(/:\d+$/,"")){throw new a("Invalid host header")}r[f]=c.href;return r};function writeFromReadableStream(e,t){if(e.locked){throw new TypeError("ReadableStream is locked.")}else if(t.destroyed){e.cancel();return}const r=e.getReader();t.on("close",cancel);t.on("error",cancel);r.read().then(flow,cancel);return r.closed.finally((()=>{t.off("close",cancel);t.off("error",cancel)}));function cancel(e){r.cancel(e).catch((()=>{}));if(e){t.destroy(e)}}function onDrain(){r.read().then(flow,cancel)}function flow({done:e,value:s}){try{if(e){t.end()}else if(!t.write(s)){t.once("drain",onDrain)}else{return r.read().then(flow,cancel)}}catch(e){cancel(e)}}}var buildOutgoingHttpHeaders=e=>{const t={};if(!(e instanceof Headers)){e=new Headers(e??void 0)}const r=[];for(const[s,n]of e){if(s==="set-cookie"){r.push(n)}else{t[s]=n}}if(r.length>0){t["set-cookie"]=r}t["content-type"]??="text/plain; charset=UTF-8";return t};var w=Symbol("responseCache");var y=Symbol("getResponseCache");var m=Symbol("cache");var v=global.Response;var O=class _Response{#e;#t;[y](){delete this[m];return this[w]||=new v(this.#e,this.#t)}constructor(e,t){this.#e=e;if(t instanceof _Response){const e=t[w];if(e){this.#t=e;this[y]();return}else{this.#t=t.#t}}else{this.#t=t}if(typeof e==="string"||typeof e?.getReader!=="undefined"){let r=t?.headers||{"content-type":"text/plain; charset=UTF-8"};if(r instanceof Headers){r=buildOutgoingHttpHeaders(r)}this[m]=[t?.status||200,e,r]}}};["body","bodyUsed","headers","ok","redirected","status","statusText","trailers","type","url"].forEach((e=>{Object.defineProperty(O.prototype,e,{get(){return this[y]()[e]}})}));["arrayBuffer","blob","clone","formData","json","text"].forEach((e=>{Object.defineProperty(O.prototype,e,{value:function(){return this[y]()[e]()}})}));Object.setPrototypeOf(O,v);Object.setPrototypeOf(O.prototype,v.prototype);var R=Reflect.ownKeys(new v).find((e=>typeof e==="symbol"&&e.toString()==="Symbol(state)"));if(!R){console.warn("Failed to find Response internal state key")}function getInternalBody(e){if(!R){return}if(e instanceof O){e=e[y]()}const t=e[R];return t&&t.body||void 0}var x="x-hono-already-sent";var E=global.fetch;if(typeof global.crypto==="undefined"){global.crypto=o}global.fetch=(e,t)=>{t={compress:false,...t};return E(e,t)};var S=/^no$/i;var H=/^(application\/json\b|text\/(?!event-stream\b))/i;var handleRequestError=()=>new Response(null,{status:400});var handleFetchError=e=>new Response(null,{status:e instanceof Error&&(e.name==="TimeoutError"||e.constructor.name==="TimeoutError")?504:500});var handleResponseError=(e,t)=>{const r=e instanceof Error?e:new Error("unknown error",{cause:e});if(r.code==="ERR_STREAM_PREMATURE_CLOSE"){console.info("The user aborted a request.")}else{console.error(e);if(!t.headersSent){t.writeHead(500,{"Content-Type":"text/plain"})}t.end(`Error: ${r.message}`);t.destroy(r)}};var responseViaCache=(e,t)=>{const[r,s,n]=e[m];if(typeof s==="string"){n["Content-Length"]=Buffer.byteLength(s);t.writeHead(r,n);t.end(s)}else{t.writeHead(r,n);return writeFromReadableStream(s,t)?.catch((e=>handleResponseError(e,t)))}};var responseViaResponseObject=async(e,t,r={})=>{if(e instanceof Promise){if(r.errorHandler){try{e=await e}catch(t){const s=await r.errorHandler(t);if(!s){return}e=s}}else{e=await e.catch(handleFetchError)}}if(m in e){return responseViaCache(e,t)}const s=buildOutgoingHttpHeaders(e.headers);const n=getInternalBody(e);if(n){const{length:r,source:i,stream:o}=n;if(i instanceof Uint8Array&&i.byteLength!==r){}else{if(r){s["content-length"]=r}t.writeHead(e.status,s);if(typeof i==="string"||i instanceof Uint8Array){t.end(i)}else if(i instanceof Blob){t.end(new Uint8Array(await i.arrayBuffer()))}else{await writeFromReadableStream(o,t)}return}}if(e.body){const{"transfer-encoding":r,"content-encoding":n,"content-length":i,"x-accel-buffering":o,"content-type":a}=s;if(r||n||i||o&&S.test(o)||!H.test(a)){t.writeHead(e.status,s);await writeFromReadableStream(e.body,t)}else{const r=await e.arrayBuffer();s["content-length"]=r.byteLength;t.writeHead(e.status,s);t.end(new Uint8Array(r))}}else if(s[x]){}else{t.writeHead(e.status,s);t.end()}};var getRequestListener=(e,t={})=>{if(t.overrideGlobalObjects!==false&&global.Request!==l){Object.defineProperty(global,"Request",{value:l});Object.defineProperty(global,"Response",{value:O})}return async(r,s)=>{let n,i;try{i=newRequest(r,t.hostname);s.on("close",(()=>{const e=i[p];if(!e){return}if(r.errored){i[p].abort(r.errored.toString())}else if(!s.writableFinished){i[p].abort("Client connection prematurely closed.")}}));n=e(i,{incoming:r,outgoing:s});if(m in n){return responseViaCache(n,s)}}catch(e){if(!n){if(t.errorHandler){n=await t.errorHandler(i?e:toRequestError(e));if(!n){return}}else if(!i){n=handleRequestError()}else{n=handleFetchError(e)}}else{return handleResponseError(e,s)}}try{return responseViaResponseObject(n,s,t)}catch(e){return handleResponseError(e,s)}}};var createAdaptorServer=e=>{const t=e.fetch;const r=getRequestListener(t,{hostname:e.hostname,overrideGlobalObjects:e.overrideGlobalObjects});const n=e.createServer||s.createServer;const i=n(e.serverOptions||{},r);return i};var serve=(e,t)=>{const r=createAdaptorServer(e);r.listen(e?.port??3e3,e.hostname,(()=>{const e=r.address();t&&t(e)}));return r};var compose=(e,t,r)=>(s,n)=>{let i=-1;return dispatch(0);async function dispatch(o){if(o<=i){throw new Error("next() called multiple times")}i=o;let a;let c=false;let l;if(e[o]){l=e[o][0][0];s.req.routeIndex=o}else{l=o===e.length&&n||void 0}if(l){try{a=await l(s,(()=>dispatch(o+1)))}catch(e){if(e instanceof Error&&t){s.error=e;a=await t(e,s);c=true}else{throw e}}}else{if(s.finalized===false&&r){a=await r(s)}}if(a&&(s.finalized===false||c)){s.res=a}return s}};var parseBody=async(e,t=Object.create(null))=>{const{all:r=false,dot:s=false}=t;const n=e instanceof j?e.raw.headers:e.headers;const i=n.get("Content-Type");if(i?.startsWith("multipart/form-data")||i?.startsWith("application/x-www-form-urlencoded")){return parseFormData(e,{all:r,dot:s})}return{}};async function parseFormData(e,t){const r=await e.formData();if(r){return convertFormDataToBodyData(r,t)}return{}}function convertFormDataToBodyData(e,t){const r=Object.create(null);e.forEach(((e,s)=>{const n=t.all||s.endsWith("[]");if(!n){r[s]=e}else{handleParsingAllValues(r,s,e)}}));if(t.dot){Object.entries(r).forEach((([e,t])=>{const s=e.includes(".");if(s){handleParsingNestedValues(r,e,t);delete r[e]}}))}return r}var handleParsingAllValues=(e,t,r)=>{if(e[t]!==void 0){if(Array.isArray(e[t])){e[t].push(r)}else{e[t]=[e[t],r]}}else{e[t]=r}};var handleParsingNestedValues=(e,t,r)=>{let s=e;const n=t.split(".");n.forEach(((e,t)=>{if(t===n.length-1){s[e]=r}else{if(!s[e]||typeof s[e]!=="object"||Array.isArray(s[e])||s[e]instanceof File){s[e]=Object.create(null)}s=s[e]}}))};var splitPath=e=>{const t=e.split("/");if(t[0]===""){t.shift()}return t};var splitRoutingPath=e=>{const{groups:t,path:r}=extractGroupsFromPath(e);const s=splitPath(r);return replaceGroupMarks(s,t)};var extractGroupsFromPath=e=>{const t=[];e=e.replace(/\{[^}]+\}/g,((e,r)=>{const s=`@${r}`;t.push([s,e]);return s}));return{groups:t,path:e}};var replaceGroupMarks=(e,t)=>{for(let r=t.length-1;r>=0;r--){const[s]=t[r];for(let n=e.length-1;n>=0;n--){if(e[n].includes(s)){e[n]=e[n].replace(s,t[r][1]);break}}}return e};var T={};var getPattern=(e,t)=>{if(e==="*"){return"*"}const r=e.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);if(r){const s=`${e}#${t}`;if(!T[s]){if(r[2]){T[s]=t&&t[0]!==":"&&t[0]!=="*"?[s,r[1],new RegExp(`^${r[2]}(?=/${t})`)]:[e,r[1],new RegExp(`^${r[2]}$`)]}else{T[s]=[e,r[1],true]}}return T[s]}return null};var tryDecode=(e,t)=>{try{return t(e)}catch{return e.replace(/(?:%[0-9A-Fa-f]{2})+/g,(e=>{try{return t(e)}catch{return e}}))}};var tryDecodeURI=e=>tryDecode(e,decodeURI);var getPath=e=>{const t=e.url;const r=t.indexOf("/",8);let s=r;for(;s<t.length;s++){const e=t.charCodeAt(s);if(e===37){const e=t.indexOf("?",s);const n=t.slice(r,e===-1?void 0:e);return tryDecodeURI(n.includes("%25")?n.replace(/%25/g,"%2525"):n)}else if(e===63){break}}return t.slice(r,s)};var getQueryStrings=e=>{const t=e.indexOf("?",8);return t===-1?"":"?"+e.slice(t+1)};var getPathNoStrict=e=>{const t=getPath(e);return t.length>1&&t.at(-1)==="/"?t.slice(0,-1):t};var mergePath=(e,t,...r)=>{if(r.length){t=mergePath(t,...r)}return`${e?.[0]==="/"?"":"/"}${e}${t==="/"?"":`${e?.at(-1)==="/"?"":"/"}${t?.[0]==="/"?t.slice(1):t}`}`};var checkOptionalParameter=e=>{if(e.charCodeAt(e.length-1)!==63||!e.includes(":")){return null}const t=e.split("/");const r=[];let s="";t.forEach((e=>{if(e!==""&&!/\:/.test(e)){s+="/"+e}else if(/\:/.test(e)){if(/\?/.test(e)){if(r.length===0&&s===""){r.push("/")}else{r.push(s)}const t=e.replace("?","");s+="/"+t;r.push(s)}else{s+="/"+e}}}));return r.filter(((e,t,r)=>r.indexOf(e)===t))};var _decodeURI=e=>{if(!/[%+]/.test(e)){return e}if(e.indexOf("+")!==-1){e=e.replace(/\+/g," ")}return e.indexOf("%")!==-1?P(e):e};var _getQueryParam=(e,t,r)=>{let s;if(!r&&t&&!/[%+]/.test(t)){let r=e.indexOf(`?${t}`,8);if(r===-1){r=e.indexOf(`&${t}`,8)}while(r!==-1){const s=e.charCodeAt(r+t.length+1);if(s===61){const s=r+t.length+2;const n=e.indexOf("&",s);return _decodeURI(e.slice(s,n===-1?void 0:n))}else if(s==38||isNaN(s)){return""}r=e.indexOf(`&${t}`,r+1)}s=/[%+]/.test(e);if(!s){return void 0}}const n={};s??=/[%+]/.test(e);let i=e.indexOf("?",8);while(i!==-1){const t=e.indexOf("&",i+1);let o=e.indexOf("=",i);if(o>t&&t!==-1){o=-1}let a=e.slice(i+1,o===-1?t===-1?void 0:t:o);if(s){a=_decodeURI(a)}i=t;if(a===""){continue}let c;if(o===-1){c=""}else{c=e.slice(o+1,t===-1?void 0:t);if(s){c=_decodeURI(c)}}if(r){if(!(n[a]&&Array.isArray(n[a]))){n[a]=[]}n[a].push(c)}else{n[a]??=c}}return t?n[t]:n};var _=_getQueryParam;var getQueryParams=(e,t)=>_getQueryParam(e,t,true);var P=decodeURIComponent;var tryDecodeURIComponent=e=>tryDecode(e,P);var j=class{raw;#r;#s;routeIndex=0;path;bodyCache={};constructor(e,t="/",r=[[]]){this.raw=e;this.path=t;this.#s=r;this.#r={}}param(e){return e?this.#n(e):this.#i()}#n(e){const t=this.#s[0][this.routeIndex][1][e];const r=this.#o(t);return r?/\%/.test(r)?tryDecodeURIComponent(r):r:void 0}#i(){const e={};const t=Object.keys(this.#s[0][this.routeIndex][1]);for(const r of t){const t=this.#o(this.#s[0][this.routeIndex][1][r]);if(t&&typeof t==="string"){e[r]=/\%/.test(t)?tryDecodeURIComponent(t):t}}return e}#o(e){return this.#s[1]?this.#s[1][e]:e}query(e){return _(this.url,e)}queries(e){return getQueryParams(this.url,e)}header(e){if(e){return this.raw.headers.get(e)??void 0}const t={};this.raw.headers.forEach(((e,r)=>{t[r]=e}));return t}async parseBody(e){return this.bodyCache.parsedBody??=await parseBody(this,e)}#a=e=>{const{bodyCache:t,raw:r}=this;const s=t[e];if(s){return s}const n=Object.keys(t)[0];if(n){return t[n].then((t=>{if(n==="json"){t=JSON.stringify(t)}return new Response(t)[e]()}))}return t[e]=r[e]()};json(){return this.#a("json")}text(){return this.#a("text")}arrayBuffer(){return this.#a("arrayBuffer")}blob(){return this.#a("blob")}formData(){return this.#a("formData")}addValidatedData(e,t){this.#r[e]=t}valid(e){return this.#r[e]}get url(){return this.raw.url}get method(){return this.raw.method}get matchedRoutes(){return this.#s[0].map((([[,e]])=>e))}get routePath(){return this.#s[0].map((([[,e]])=>e))[this.routeIndex].path}};var A={Stringify:1,BeforeStream:2,Stream:3};var raw=(e,t)=>{const r=new String(e);r.isEscaped=true;r.callbacks=t;return r};var k=/[&<>'"]/;var stringBufferToString=async(e,t)=>{let r="";t||=[];const s=await Promise.all(e);for(let e=s.length-1;;e--){r+=s[e];e--;if(e<0){break}let n=s[e];if(typeof n==="object"){t.push(...n.callbacks||[])}const i=n.isEscaped;n=await(typeof n==="object"?n.toString():n);if(typeof n==="object"){t.push(...n.callbacks||[])}if(n.isEscaped??i){r+=n}else{const e=[r];escapeToBuffer(n,e);r=e[0]}}return raw(r,t)};var escapeToBuffer=(e,t)=>{const r=e.search(k);if(r===-1){t[0]+=e;return}let s;let n;let i=0;for(n=r;n<e.length;n++){switch(e.charCodeAt(n)){case 34:s="&quot;";break;case 39:s="&#39;";break;case 38:s="&amp;";break;case 60:s="&lt;";break;case 62:s="&gt;";break;default:continue}t[0]+=e.substring(i,n)+s;i=n+1}t[0]+=e.substring(i,n)};var resolveCallbackSync=e=>{const t=e.callbacks;if(!t?.length){return e}const r=[e];const s={};t.forEach((e=>e({phase:A.Stringify,buffer:r,context:s})));return r[0]};var resolveCallback=async(e,t,r,s,n)=>{if(typeof e==="object"&&!(e instanceof String)){if(!(e instanceof Promise)){e=e.toString()}if(e instanceof Promise){e=await e}}const i=e.callbacks;if(!i?.length){return Promise.resolve(e)}if(n){n[0]+=e}else{n=[e]}const o=Promise.all(i.map((e=>e({phase:t,buffer:n,context:s})))).then((e=>Promise.all(e.filter(Boolean).map((e=>resolveCallback(e,t,false,s,n)))).then((()=>n[0]))));if(r){return raw(await o,i)}else{return o}};var $="text/plain; charset=UTF-8";var setHeaders=(e,t={})=>{for(const r of Object.keys(t)){e.set(r,t[r])}return e};var C=class{#c;#l;env={};#h;finalized=false;error;#u=200;#d;#f;#p;#b;#g=true;#w;#y;#m;#s;#v;constructor(e,t){this.#c=e;if(t){this.#d=t.executionCtx;this.env=t.env;this.#m=t.notFoundHandler;this.#v=t.path;this.#s=t.matchResult}}get req(){this.#l??=new j(this.#c,this.#v,this.#s);return this.#l}get event(){if(this.#d&&"respondWith"in this.#d){return this.#d}else{throw Error("This context has no FetchEvent")}}get executionCtx(){if(this.#d){return this.#d}else{throw Error("This context has no ExecutionContext")}}get res(){this.#g=false;return this.#b||=new Response("404 Not Found",{status:404})}set res(e){this.#g=false;if(this.#b&&e){try{for(const[t,r]of this.#b.headers.entries()){if(t==="content-type"){continue}if(t==="set-cookie"){const t=this.#b.headers.getSetCookie();e.headers.delete("set-cookie");for(const r of t){e.headers.append("set-cookie",r)}}else{e.headers.set(t,r)}}}catch(t){if(t instanceof TypeError&&t.message.includes("immutable")){this.res=new Response(e.body,{headers:e.headers,status:e.status});return}else{throw t}}}this.#b=e;this.finalized=true}render=(...e)=>{this.#y??=e=>this.html(e);return this.#y(...e)};setLayout=e=>this.#w=e;getLayout=()=>this.#w;setRenderer=e=>{this.#y=e};header=(e,t,r)=>{if(t===void 0){if(this.#f){this.#f.delete(e)}else if(this.#p){delete this.#p[e.toLocaleLowerCase()]}if(this.finalized){this.res.headers.delete(e)}return}if(r?.append){if(!this.#f){this.#g=false;this.#f=new Headers(this.#p);this.#p={}}this.#f.append(e,t)}else{if(this.#f){this.#f.set(e,t)}else{this.#p??={};this.#p[e.toLowerCase()]=t}}if(this.finalized){if(r?.append){this.res.headers.append(e,t)}else{this.res.headers.set(e,t)}}};status=e=>{this.#g=false;this.#u=e};set=(e,t)=>{this.#h??=new Map;this.#h.set(e,t)};get=e=>this.#h?this.#h.get(e):void 0;get var(){if(!this.#h){return{}}return Object.fromEntries(this.#h)}#O(e,t,r){if(this.#g&&!r&&!t&&this.#u===200){return new Response(e,{headers:this.#p})}if(t&&typeof t!=="number"){const r=new Headers(t.headers);if(this.#f){this.#f.forEach(((e,t)=>{if(t==="set-cookie"){r.append(t,e)}else{r.set(t,e)}}))}const s=setHeaders(r,this.#p);return new Response(e,{headers:s,status:t.status??this.#u})}const s=typeof t==="number"?t:this.#u;this.#p??={};this.#f??=new Headers;setHeaders(this.#f,this.#p);if(this.#b){this.#b.headers.forEach(((e,t)=>{if(t==="set-cookie"){this.#f?.append(t,e)}else{this.#f?.set(t,e)}}));setHeaders(this.#f,this.#p)}r??={};for(const[e,t]of Object.entries(r)){if(typeof t==="string"){this.#f.set(e,t)}else{this.#f.delete(e);for(const r of t){this.#f.append(e,r)}}}return new Response(e,{status:s,headers:this.#f})}newResponse=(...e)=>this.#O(...e);body=(e,t,r)=>typeof t==="number"?this.#O(e,t,r):this.#O(e,t);text=(e,t,r)=>{if(!this.#p){if(this.#g&&!r&&!t){return new Response(e)}this.#p={}}this.#p["content-type"]=$;if(typeof t==="number"){return this.#O(e,t,r)}return this.#O(e,t)};json=(e,t,r)=>{const s=JSON.stringify(e);this.#p??={};this.#p["content-type"]="application/json";return typeof t==="number"?this.#O(s,t,r):this.#O(s,t)};html=(e,t,r)=>{this.#p??={};this.#p["content-type"]="text/html; charset=UTF-8";if(typeof e==="object"){return resolveCallback(e,A.Stringify,false,{}).then((e=>typeof t==="number"?this.#O(e,t,r):this.#O(e,t)))}return typeof t==="number"?this.#O(e,t,r):this.#O(e,t)};redirect=(e,t)=>{this.#f??=new Headers;this.#f.set("Location",String(e));return this.newResponse(null,t??302)};notFound=()=>{this.#m??=()=>new Response;return this.#m(this)}};var I="ALL";var q="all";var L=["get","post","put","delete","options","patch"];var B="Can not add a route since the matcher is already built.";var F=class extends Error{};var U="__COMPOSED_HANDLER";var notFoundHandler=e=>e.text("404 Not Found",404);var errorHandler=(e,t)=>{if("getResponse"in e){return e.getResponse()}console.error(e);return t.text("Internal Server Error",500)};var D=class{get;post;put;delete;options;patch;all;on;use;router;getPath;_basePath="/";#v="/";routes=[];constructor(e={}){const t=[...L,q];t.forEach((e=>{this[e]=(t,...r)=>{if(typeof t==="string"){this.#v=t}else{this.#R(e,this.#v,t)}r.forEach((t=>{this.#R(e,this.#v,t)}));return this}}));this.on=(e,t,...r)=>{for(const s of[t].flat()){this.#v=s;for(const t of[e].flat()){r.map((e=>{this.#R(t.toUpperCase(),this.#v,e)}))}}return this};this.use=(e,...t)=>{if(typeof e==="string"){this.#v=e}else{this.#v="*";t.unshift(e)}t.forEach((e=>{this.#R(I,this.#v,e)}));return this};const{strict:r,...s}=e;Object.assign(this,s);this.getPath=r??true?e.getPath??getPath:getPathNoStrict}#x(){const e=new D({router:this.router,getPath:this.getPath});e.routes=this.routes;return e}#m=notFoundHandler;errorHandler=errorHandler;route(e,t){const r=this.basePath(e);t.routes.map((e=>{let s;if(t.errorHandler===errorHandler){s=e.handler}else{s=async(r,s)=>(await compose([],t.errorHandler)(r,(()=>e.handler(r,s)))).res;s[U]=e.handler}r.#R(e.method,e.path,s)}));return this}basePath(e){const t=this.#x();t._basePath=mergePath(this._basePath,e);return t}onError=e=>{this.errorHandler=e;return this};notFound=e=>{this.#m=e;return this};mount(e,t,r){let s;let n;if(r){if(typeof r==="function"){n=r}else{n=r.optionHandler;s=r.replaceRequest}}const i=n?e=>{const t=n(e);return Array.isArray(t)?t:[t]}:e=>{let t=void 0;try{t=e.executionCtx}catch{}return[e.env,t]};s||=(()=>{const t=mergePath(this._basePath,e);const r=t==="/"?0:t.length;return e=>{const t=new URL(e.url);t.pathname=t.pathname.slice(r)||"/";return new Request(t,e)}})();const handler=async(e,r)=>{const n=await t(s(e.req.raw),...i(e));if(n){return n}await r()};this.#R(I,mergePath(e,"*"),handler);return this}#R(e,t,r){e=e.toUpperCase();t=mergePath(this._basePath,t);const s={path:t,method:e,handler:r};this.router.add(e,t,[r,s]);this.routes.push(s)}#E(e,t){if(e instanceof Error){return this.errorHandler(e,t)}throw e}#S(e,t,r,s){if(s==="HEAD"){return(async()=>new Response(null,await this.#S(e,t,r,"GET")))()}const n=this.getPath(e,{env:r});const i=this.router.match(s,n);const o=new C(e,{path:n,matchResult:i,env:r,executionCtx:t,notFoundHandler:this.#m});if(i[0].length===1){let e;try{e=i[0][0][0][0](o,(async()=>{o.res=await this.#m(o)}))}catch(e){return this.#E(e,o)}return e instanceof Promise?e.then((e=>e||(o.finalized?o.res:this.#m(o)))).catch((e=>this.#E(e,o))):e??this.#m(o)}const a=compose(i[0],this.errorHandler,this.#m);return(async()=>{try{const e=await a(o);if(!e.finalized){throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?")}return e.res}catch(e){return this.#E(e,o)}})()}fetch=(e,...t)=>this.#S(e,t[1],t[0],e.method);request=(e,t,r,s)=>{if(e instanceof Request){return this.fetch(t?new Request(e,t):e,r,s)}e=e.toString();return this.fetch(new Request(/^https?:\/\//.test(e)?e:`http://localhost${mergePath("/",e)}`,t),r,s)};fire=()=>{addEventListener("fetch",(e=>{e.respondWith(this.#S(e.request,e,void 0,e.request.method))}))}};var M="[^/]+";var W=".*";var N="(?:|/.*)";var G=Symbol();var K=new Set(".\\+*[^]$()");function compareKey(e,t){if(e.length===1){return t.length===1?e<t?-1:1:-1}if(t.length===1){return 1}if(e===W||e===N){return 1}else if(t===W||t===N){return-1}if(e===M){return 1}else if(t===M){return-1}return e.length===t.length?e<t?-1:1:t.length-e.length}var z=class{#H;#T;#_=Object.create(null);insert(e,t,r,s,n){if(e.length===0){if(this.#H!==void 0){throw G}if(n){return}this.#H=t;return}const[i,...o]=e;const a=i==="*"?o.length===0?["","",W]:["","",M]:i==="/*"?["","",N]:i.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);let c;if(a){const e=a[1];let t=a[2]||M;if(e&&a[2]){t=t.replace(/^\((?!\?:)(?=[^)]+\)$)/,"(?:");if(/\((?!\?:)/.test(t)){throw G}}c=this.#_[t];if(!c){if(Object.keys(this.#_).some((e=>e!==W&&e!==N))){throw G}if(n){return}c=this.#_[t]=new z;if(e!==""){c.#T=s.varIndex++}}if(!n&&e!==""){r.push([e,c.#T])}}else{c=this.#_[i];if(!c){if(Object.keys(this.#_).some((e=>e.length>1&&e!==W&&e!==N))){throw G}if(n){return}c=this.#_[i]=new z}}c.insert(o,t,r,s,n)}buildRegExpStr(){const e=Object.keys(this.#_).sort(compareKey);const t=e.map((e=>{const t=this.#_[e];return(typeof t.#T==="number"?`(${e})@${t.#T}`:K.has(e)?`\\${e}`:e)+t.buildRegExpStr()}));if(typeof this.#H==="number"){t.unshift(`#${this.#H}`)}if(t.length===0){return""}if(t.length===1){return t[0]}return"(?:"+t.join("|")+")"}};var V=class{#P={varIndex:0};#j=new z;insert(e,t,r){const s=[];const n=[];for(let t=0;;){let r=false;e=e.replace(/\{[^}]+\}/g,(e=>{const s=`@\\${t}`;n[t]=[s,e];t++;r=true;return s}));if(!r){break}}const i=e.match(/(?::[^\/]+)|(?:\/\*$)|./g)||[];for(let e=n.length-1;e>=0;e--){const[t]=n[e];for(let r=i.length-1;r>=0;r--){if(i[r].indexOf(t)!==-1){i[r]=i[r].replace(t,n[e][1]);break}}}this.#j.insert(i,t,s,this.#P,r);return s}buildRegExp(){let e=this.#j.buildRegExpStr();if(e===""){return[/^$/,[],[]]}let t=0;const r=[];const s=[];e=e.replace(/#(\d+)|@(\d+)|\.\*\$/g,((e,n,i)=>{if(n!==void 0){r[++t]=Number(n);return"$()"}if(i!==void 0){s[Number(i)]=++t;return""}return""}));return[new RegExp(`^${e}`),r,s]}};var Z=[];var J=[/^$/,[],Object.create(null)];var X=Object.create(null);function buildWildcardRegExp(e){return X[e]??=new RegExp(e==="*"?"":`^${e.replace(/\/\*$|([.\\+*[^\]$()])/g,((e,t)=>t?`\\${t}`:"(?:|/.*)"))}$`)}function clearWildcardRegExpCache(){X=Object.create(null)}function buildMatcherFromPreprocessedRoutes(e){const t=new V;const r=[];if(e.length===0){return J}const s=e.map((e=>[!/\*|\/:/.test(e[0]),...e])).sort((([e,t],[r,s])=>e?1:r?-1:t.length-s.length));const n=Object.create(null);for(let e=0,i=-1,o=s.length;e<o;e++){const[o,a,c]=s[e];if(o){n[a]=[c.map((([e])=>[e,Object.create(null)])),Z]}else{i++}let l;try{l=t.insert(a,i,o)}catch(e){throw e===G?new F(a):e}if(o){continue}r[i]=c.map((([e,t])=>{const r=Object.create(null);t-=1;for(;t>=0;t--){const[e,s]=l[t];r[e]=s}return[e,r]}))}const[i,o,a]=t.buildRegExp();for(let e=0,t=r.length;e<t;e++){for(let t=0,s=r[e].length;t<s;t++){const s=r[e][t]?.[1];if(!s){continue}const n=Object.keys(s);for(let e=0,t=n.length;e<t;e++){s[n[e]]=a[s[n[e]]]}}}const c=[];for(const e in o){c[e]=r[o[e]]}return[i,c,n]}function findMiddleware(e,t){if(!e){return void 0}for(const r of Object.keys(e).sort(((e,t)=>t.length-e.length))){if(buildWildcardRegExp(r).test(t)){return[...e[r]]}}return void 0}var Q=class{name="RegExpRouter";#A;#k;constructor(){this.#A={[I]:Object.create(null)};this.#k={[I]:Object.create(null)}}add(e,t,r){const s=this.#A;const n=this.#k;if(!s||!n){throw new Error(B)}if(!s[e]){[s,n].forEach((t=>{t[e]=Object.create(null);Object.keys(t[I]).forEach((r=>{t[e][r]=[...t[I][r]]}))}))}if(t==="/*"){t="*"}const i=(t.match(/\/:/g)||[]).length;if(/\*$/.test(t)){const o=buildWildcardRegExp(t);if(e===I){Object.keys(s).forEach((e=>{s[e][t]||=findMiddleware(s[e],t)||findMiddleware(s[I],t)||[]}))}else{s[e][t]||=findMiddleware(s[e],t)||findMiddleware(s[I],t)||[]}Object.keys(s).forEach((t=>{if(e===I||e===t){Object.keys(s[t]).forEach((e=>{o.test(e)&&s[t][e].push([r,i])}))}}));Object.keys(n).forEach((t=>{if(e===I||e===t){Object.keys(n[t]).forEach((e=>o.test(e)&&n[t][e].push([r,i])))}}));return}const o=checkOptionalParameter(t)||[t];for(let t=0,a=o.length;t<a;t++){const c=o[t];Object.keys(n).forEach((o=>{if(e===I||e===o){n[o][c]||=[...findMiddleware(s[o],c)||findMiddleware(s[I],c)||[]];n[o][c].push([r,i-a+t+1])}}))}}match(e,t){clearWildcardRegExpCache();const r=this.#$();this.match=(e,t)=>{const s=r[e]||r[I];const n=s[2][t];if(n){return n}const i=t.match(s[0]);if(!i){return[[],Z]}const o=i.indexOf("",1);return[s[1][o],i]};return this.match(e,t)}#$(){const e=Object.create(null);Object.keys(this.#k).concat(Object.keys(this.#A)).forEach((t=>{e[t]||=this.#C(t)}));this.#A=this.#k=void 0;return e}#C(e){const t=[];let r=e===I;[this.#A,this.#k].forEach((s=>{const n=s[e]?Object.keys(s[e]).map((t=>[t,s[e][t]])):[];if(n.length!==0){r||=true;t.push(...n)}else if(e!==I){t.push(...Object.keys(s[I]).map((e=>[e,s[I][e]])))}}));if(!r){return null}else{return buildMatcherFromPreprocessedRoutes(t)}}};var Y=class{name="SmartRouter";#I=[];#k=[];constructor(e){this.#I=e.routers}add(e,t,r){if(!this.#k){throw new Error(B)}this.#k.push([e,t,r])}match(e,t){if(!this.#k){throw new Error("Fatal error")}const r=this.#I;const s=this.#k;const n=r.length;let i=0;let o;for(;i<n;i++){const n=r[i];try{for(let e=0,t=s.length;e<t;e++){n.add(...s[e])}o=n.match(e,t)}catch(e){if(e instanceof F){continue}throw e}this.match=n.match.bind(n);this.#I=[n];this.#k=void 0;break}if(i===n){throw new Error("Fatal error")}this.name=`SmartRouter + ${this.activeRouter.name}`;return o}get activeRouter(){if(this.#k||this.#I.length!==1){throw new Error("No active router has been determined yet.")}return this.#I[0]}};var ee=Object.create(null);var te=class{#q;#_;#L;#B=0;#F=ee;constructor(e,t,r){this.#_=r||Object.create(null);this.#q=[];if(e&&t){const r=Object.create(null);r[e]={handler:t,possibleKeys:[],score:0};this.#q=[r]}this.#L=[]}insert(e,t,r){this.#B=++this.#B;let s=this;const n=splitRoutingPath(t);const i=[];for(let e=0,t=n.length;e<t;e++){const t=n[e];const r=n[e+1];const o=getPattern(t,r);const a=Array.isArray(o)?o[0]:t;if(Object.keys(s.#_).includes(a)){s=s.#_[a];const e=getPattern(t,r);if(e){i.push(e[1])}continue}s.#_[a]=new te;if(o){s.#L.push(o);i.push(o[1])}s=s.#_[a]}const o=Object.create(null);const a={handler:r,possibleKeys:i.filter(((e,t,r)=>r.indexOf(e)===t)),score:this.#B};o[e]=a;s.#q.push(o);return s}#U(e,t,r,s){const n=[];for(let i=0,o=e.#q.length;i<o;i++){const o=e.#q[i];const a=o[t]||o[I];const c={};if(a!==void 0){a.params=Object.create(null);n.push(a);if(r!==ee||s&&s!==ee){for(let e=0,t=a.possibleKeys.length;e<t;e++){const t=a.possibleKeys[e];const n=c[a.score];a.params[t]=s?.[t]&&!n?s[t]:r[t]??s?.[t];c[a.score]=true}}}}return n}search(e,t){const r=[];this.#F=ee;const s=this;let n=[s];const i=splitPath(t);const o=[];for(let t=0,s=i.length;t<s;t++){const a=i[t];const c=t===s-1;const l=[];for(let s=0,h=n.length;s<h;s++){const h=n[s];const u=h.#_[a];if(u){u.#F=h.#F;if(c){if(u.#_["*"]){r.push(...this.#U(u.#_["*"],e,h.#F))}r.push(...this.#U(u,e,h.#F))}else{l.push(u)}}for(let s=0,n=h.#L.length;s<n;s++){const n=h.#L[s];const u=h.#F===ee?{}:{...h.#F};if(n==="*"){const t=h.#_["*"];if(t){r.push(...this.#U(t,e,h.#F));t.#F=u;l.push(t)}continue}if(a===""){continue}const[d,f,p]=n;const b=h.#_[d];const g=i.slice(t).join("/");if(p instanceof RegExp){const t=p.exec(g);if(t){u[f]=t[0];r.push(...this.#U(b,e,h.#F,u));if(Object.keys(b.#_).length){b.#F=u;const e=t[0].match(/\//)?.length??0;const r=o[e]||=[];r.push(b)}continue}}if(p===true||p.test(a)){u[f]=a;if(c){r.push(...this.#U(b,e,u,h.#F));if(b.#_["*"]){r.push(...this.#U(b.#_["*"],e,u,h.#F))}}else{b.#F=u;l.push(b)}}}}n=l.concat(o.shift()??[])}if(r.length>1){r.sort(((e,t)=>e.score-t.score))}return[r.map((({handler:e,params:t})=>[e,t]))]}};var re=class{name="TrieRouter";#D;constructor(){this.#D=new te}add(e,t,r){const s=checkOptionalParameter(t);if(s){for(let t=0,n=s.length;t<n;t++){this.#D.insert(e,s[t],r)}return}this.#D.insert(e,t,r)}match(e,t){return this.#D.search(e,t)}};var se=class extends D{constructor(e={}){super(e);this.router=e.router??new Y({routers:[new Q,new re]})}};var ne=class{writer;encoder;writable;abortSubscribers=[];responseReadable;aborted=false;closed=false;constructor(e,t){this.writable=e;this.writer=e.getWriter();this.encoder=new TextEncoder;const r=t.getReader();this.abortSubscribers.push((async()=>{await r.cancel()}));this.responseReadable=new ReadableStream({async pull(e){const{done:t,value:s}=await r.read();t?e.close():e.enqueue(s)},cancel:()=>{this.abort()}})}async write(e){try{if(typeof e==="string"){e=this.encoder.encode(e)}await this.writer.write(e)}catch{}return this}async writeln(e){await this.write(e+"\n");return this}sleep(e){return new Promise((t=>setTimeout(t,e)))}async close(){try{await this.writer.close()}catch{}this.closed=true}async pipe(e){this.writer.releaseLock();await e.pipeTo(this.writable,{preventClose:true});this.writer=this.writable.getWriter()}onAbort(e){this.abortSubscribers.push(e)}abort(){if(!this.aborted){this.aborted=true;this.abortSubscribers.forEach((e=>e()))}}};var utils_isOldBunVersion=()=>{const e=typeof Bun!=="undefined"?Bun.version:void 0;if(e===void 0){return false}const t=e.startsWith("1.1")||e.startsWith("1.0")||e.startsWith("0.");utils_isOldBunVersion=()=>t;return t};var ie=new WeakMap;var stream=(e,t,r)=>{const{readable:s,writable:n}=new TransformStream;const i=new ne(n,s);if(utils_isOldBunVersion()){e.req.raw.signal.addEventListener("abort",(()=>{if(!i.closed){i.abort()}}))}ie.set(i.responseReadable,e);(async()=>{try{await t(i)}catch(e){if(e===void 0){}else if(e instanceof Error&&r){await r(e,i)}else{console.error(e)}}finally{i.close()}})();return e.newResponse(i.responseReadable)};var oe=class extends ne{constructor(e,t){super(e,t)}async writeSSE(e){const t=await resolveCallback(e.data,A.Stringify,false,{});const r=t.split("\n").map((e=>`data: ${e}`)).join("\n");const s=[e.event&&`event: ${e.event}`,r,e.id&&`id: ${e.id}`,e.retry&&`retry: ${e.retry}`].filter(Boolean).join("\n")+"\n\n";await this.write(s)}};var run=async(e,t,r)=>{try{await t(e)}catch(t){if(t instanceof Error&&r){await r(t,e);await e.writeSSE({event:"error",data:t.message})}else{console.error(t)}}finally{e.close()}};var ae=new WeakMap;var streamSSE=(e,t,r)=>{const{readable:s,writable:n}=new TransformStream;const i=new oe(n,s);if(isOldBunVersion()){e.req.raw.signal.addEventListener("abort",(()=>{if(!i.closed){i.abort()}}))}ae.set(i.responseReadable,e);e.header("Transfer-Encoding","chunked");e.header("Content-Type","text/event-stream");e.header("Cache-Control","no-cache");e.header("Connection","keep-alive");run(i,t,r);return e.newResponse(i.responseReadable)};var streamText=(e,t,r)=>{e.header("Content-Type",$);e.header("X-Content-Type-Options","nosniff");e.header("Transfer-Encoding","chunked");return stream(e,t,r)};const ce=require("node:child_process");const le=require("node:crypto");var he=__nccwpck_require__.t(le,2);
//! otpauth 9.3.6 | (c) Héctor Molinero Fernández | MIT | https://github.com/hectorm/otpauth
const uintDecode=e=>{const t=new ArrayBuffer(8);const r=new Uint8Array(t);let s=e;for(let e=7;e>=0;e--){if(s===0)break;r[e]=s&255;s-=r[e];s/=256}return r};const ue=(()=>{if(typeof globalThis==="object")return globalThis;else{Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:true});try{if(typeof __GLOBALTHIS__!=="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}}if(typeof self!=="undefined")return self;else if(typeof window!=="undefined")return window;else if(typeof global!=="undefined")return global;return undefined})();const canonicalizeAlgorithm=e=>{switch(true){case/^(?:SHA-?1|SSL3-SHA1)$/i.test(e):return"SHA1";case/^SHA(?:2?-)?224$/i.test(e):return"SHA224";case/^SHA(?:2?-)?256$/i.test(e):return"SHA256";case/^SHA(?:2?-)?384$/i.test(e):return"SHA384";case/^SHA(?:2?-)?512$/i.test(e):return"SHA512";case/^SHA3-224$/i.test(e):return"SHA3-224";case/^SHA3-256$/i.test(e):return"SHA3-256";case/^SHA3-384$/i.test(e):return"SHA3-384";case/^SHA3-512$/i.test(e):return"SHA3-512";default:throw new TypeError(`Unknown hash algorithm: ${e}`)}};const hmacDigest=(e,t,r)=>{if(he?.createHmac){const s=le.createHmac(e,ue.Buffer.from(t));s.update(ue.Buffer.from(r));return s.digest()}else{throw new Error("Missing HMAC function")}};const de="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";const base32Decode=e=>{e=e.replace(/ /g,"");let t=e.length;while(e[t-1]==="=")--t;e=(t<e.length?e.substring(0,t):e).toUpperCase();const r=new ArrayBuffer(e.length*5/8|0);const s=new Uint8Array(r);let n=0;let i=0;let o=0;for(let t=0;t<e.length;t++){const r=de.indexOf(e[t]);if(r===-1)throw new TypeError(`Invalid character found: ${e[t]}`);i=i<<5|r;n+=5;if(n>=8){n-=8;s[o++]=i>>>n}}return s};const base32Encode=e=>{let t=0;let r=0;let s="";for(let n=0;n<e.length;n++){r=r<<8|e[n];t+=8;while(t>=5){s+=de[r>>>t-5&31];t-=5}}if(t>0){s+=de[r<<5-t&31]}return s};const hexDecode=e=>{e=e.replace(/ /g,"");const t=new ArrayBuffer(e.length/2);const r=new Uint8Array(t);for(let t=0;t<e.length;t+=2){r[t/2]=parseInt(e.substring(t,t+2),16)}return r};const hexEncode=e=>{let t="";for(let r=0;r<e.length;r++){const s=e[r].toString(16);if(s.length===1)t+="0";t+=s}return t.toUpperCase()};const latin1Decode=e=>{const t=new ArrayBuffer(e.length);const r=new Uint8Array(t);for(let t=0;t<e.length;t++){r[t]=e.charCodeAt(t)&255}return r};const latin1Encode=e=>{let t="";for(let r=0;r<e.length;r++){t+=String.fromCharCode(e[r])}return t};const fe=ue.TextEncoder?new ue.TextEncoder:null;const pe=ue.TextDecoder?new ue.TextDecoder:null;const utf8Decode=e=>{if(!fe){throw new Error("Encoding API not available")}return fe.encode(e)};const utf8Encode=e=>{if(!pe){throw new Error("Encoding API not available")}return pe.decode(e)};const randomBytes=e=>{if(he?.randomBytes){return le.randomBytes(e)}else if(ue.crypto?.getRandomValues){return ue.crypto.getRandomValues(new Uint8Array(e))}else{throw new Error("Cryptography API not available")}};class Secret{static fromLatin1(e){return new Secret({buffer:latin1Decode(e).buffer})}static fromUTF8(e){return new Secret({buffer:utf8Decode(e).buffer})}static fromBase32(e){return new Secret({buffer:base32Decode(e).buffer})}static fromHex(e){return new Secret({buffer:hexDecode(e).buffer})}get buffer(){return this.bytes.buffer}get latin1(){Object.defineProperty(this,"latin1",{enumerable:true,writable:false,configurable:false,value:latin1Encode(this.bytes)});return this.latin1}get utf8(){Object.defineProperty(this,"utf8",{enumerable:true,writable:false,configurable:false,value:utf8Encode(this.bytes)});return this.utf8}get base32(){Object.defineProperty(this,"base32",{enumerable:true,writable:false,configurable:false,value:base32Encode(this.bytes)});return this.base32}get hex(){Object.defineProperty(this,"hex",{enumerable:true,writable:false,configurable:false,value:hexEncode(this.bytes)});return this.hex}constructor({buffer:e,size:t=20}={}){this.bytes=typeof e==="undefined"?randomBytes(t):new Uint8Array(e);Object.defineProperty(this,"bytes",{enumerable:true,writable:false,configurable:false,value:this.bytes})}}const timingSafeEqual=(e,t)=>{if(he?.timingSafeEqual){return le.timingSafeEqual(ue.Buffer.from(e),ue.Buffer.from(t))}else{if(e.length!==t.length){throw new TypeError("Input strings must have the same length")}let r=-1;let s=0;while(++r<e.length){s|=e.charCodeAt(r)^t.charCodeAt(r)}return s===0}};class HOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:true,algorithm:"SHA1",digits:6,counter:0,window:1}}static generate({secret:e,algorithm:t=HOTP.defaults.algorithm,digits:r=HOTP.defaults.digits,counter:s=HOTP.defaults.counter}){const n=hmacDigest(t,e.bytes,uintDecode(s));const i=n[n.byteLength-1]&15;const o=((n[i]&127)<<24|(n[i+1]&255)<<16|(n[i+2]&255)<<8|n[i+3]&255)%10**r;return o.toString().padStart(r,"0")}generate({counter:e=this.counter++}={}){return HOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate({token:e,secret:t,algorithm:r,digits:s=HOTP.defaults.digits,counter:n=HOTP.defaults.counter,window:i=HOTP.defaults.window}){if(e.length!==s)return null;let o=null;const check=i=>{const a=HOTP.generate({secret:t,algorithm:r,digits:s,counter:i});if(timingSafeEqual(e,a)){o=i-n}};check(n);for(let e=1;e<=i&&o===null;++e){check(n-e);if(o!==null)break;check(n+e);if(o!==null)break}return o}validate({token:e,counter:t=this.counter,window:r}){return HOTP.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:t,window:r})}toString(){const e=encodeURIComponent;return"otpauth://hotp/"+`${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}`+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`counter=${e(this.counter)}`}constructor({issuer:e=HOTP.defaults.issuer,label:t=HOTP.defaults.label,issuerInLabel:r=HOTP.defaults.issuerInLabel,secret:s=new Secret,algorithm:n=HOTP.defaults.algorithm,digits:i=HOTP.defaults.digits,counter:o=HOTP.defaults.counter}={}){this.issuer=e;this.label=t;this.issuerInLabel=r;this.secret=typeof s==="string"?Secret.fromBase32(s):s;this.algorithm=canonicalizeAlgorithm(n);this.digits=i;this.counter=o}}class TOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:true,algorithm:"SHA1",digits:6,period:30,window:1}}static generate({secret:e,algorithm:t,digits:r,period:s=TOTP.defaults.period,timestamp:n=Date.now()}){return HOTP.generate({secret:e,algorithm:t,digits:r,counter:Math.floor(n/1e3/s)})}generate({timestamp:e=Date.now()}={}){return TOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:t,algorithm:r,digits:s,period:n=TOTP.defaults.period,timestamp:i=Date.now(),window:o}){return HOTP.validate({token:e,secret:t,algorithm:r,digits:s,counter:Math.floor(i/1e3/n),window:o})}validate({token:e,timestamp:t,window:r}){return TOTP.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:t,window:r})}toString(){const e=encodeURIComponent;return"otpauth://totp/"+`${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}`+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`period=${e(this.period)}`}constructor({issuer:e=TOTP.defaults.issuer,label:t=TOTP.defaults.label,issuerInLabel:r=TOTP.defaults.issuerInLabel,secret:s=new Secret,algorithm:n=TOTP.defaults.algorithm,digits:i=TOTP.defaults.digits,period:o=TOTP.defaults.period}={}){this.issuer=e;this.label=t;this.issuerInLabel=r;this.secret=typeof s==="string"?Secret.fromBase32(s):s;this.algorithm=canonicalizeAlgorithm(n);this.digits=i;this.period=o}}const be=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;const ge=/^[2-7A-Z]+=*$/i;const we=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;const ye=/^[+-]?\d+$/;const me=/^\+?[1-9]\d*$/;class URI{static parse(e){let t;try{t=e.match(be)}catch(e){}if(!Array.isArray(t)){throw new URIError("Invalid URI format")}const r=t[1].toLowerCase();const s=t[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent);const n=t[3].split("&").reduce(((e,t)=>{const r=t.split(/=(.*)/,2).map(decodeURIComponent);const s=r[0].toLowerCase();const n=r[1];const i=e;i[s]=n;return i}),{});let i;const o={};if(r==="hotp"){i=HOTP;if(typeof n.counter!=="undefined"&&ye.test(n.counter)){o.counter=parseInt(n.counter,10)}else{throw new TypeError("Missing or invalid 'counter' parameter")}}else if(r==="totp"){i=TOTP;if(typeof n.period!=="undefined"){if(me.test(n.period)){o.period=parseInt(n.period,10)}else{throw new TypeError("Invalid 'period' parameter")}}}else{throw new TypeError("Unknown OTP type")}if(typeof n.issuer!=="undefined"){o.issuer=n.issuer}if(s.length===2){o.label=s[1];if(typeof o.issuer==="undefined"||o.issuer===""){o.issuer=s[0]}else if(s[0]===""){o.issuerInLabel=false}}else{o.label=s[0];if(typeof o.issuer!=="undefined"&&o.issuer!==""){o.issuerInLabel=false}}if(typeof n.secret!=="undefined"&&ge.test(n.secret)){o.secret=n.secret}else{throw new TypeError("Missing or invalid 'secret' parameter")}if(typeof n.algorithm!=="undefined"){if(we.test(n.algorithm)){o.algorithm=n.algorithm}else{throw new TypeError("Invalid 'algorithm' parameter")}}if(typeof n.digits!=="undefined"){if(me.test(n.digits)){o.digits=parseInt(n.digits,10)}else{throw new TypeError("Invalid 'digits' parameter")}}return new i(o)}static stringify(e){if(e instanceof HOTP||e instanceof TOTP){return e.toString()}throw new TypeError("Invalid 'HOTP/TOTP' object")}}const ve="9.3.6";var Oe=undefined&&undefined.__awaiter||function(e,t,r,s){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,n){function fulfilled(e){try{step(s.next(e))}catch(e){n(e)}}function rejected(e){try{step(s["throw"](e))}catch(e){n(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((s=s.apply(e,t||[])).next())}))};var Re,xe;const Ee=(xe=(Re=process.env["ALLOWED_EXECUTABLES"])===null||Re===void 0?void 0:Re.split(","))!==null&&xe!==void 0?xe:[];const Se=Number(process.env["TIMEOUT"])||1e4;const He=process.env["SECRET"];const Te=new Set;const _e=(new se).get("/health",(e=>Oe(void 0,void 0,void 0,(function*(){return e.text("OK")})))).get("/auth/:code?",(e=>Oe(void 0,void 0,void 0,(function*(){const{code:t}=e.req.param();if(!He||!t){const t=(new Secret).base32;return e.text(t)}const r=new TOTP({secret:He});if(!r.validate({token:t})){return e.text("Invalid code",403)}const s=(0,le.randomUUID)();Te.add(s);setTimeout((()=>Te.delete(s)),18e5);return e.text(s)})))).get("/:exec/*",(e=>Oe(void 0,void 0,void 0,(function*(){try{const{exec:t}=e.req.param();if(!Ee.includes(t)){return e.text("Not allowed",403)}const r=e.req.url.split("/").slice(4).map((e=>decodeURIComponent(e)));const{stdout:s,stderr:n,token:i}=e.req.query();if(i&&!Te.has(i)){return e.text("Invalid token",403)}return streamText(e,(e=>new Promise(((i,o)=>{const a=(0,ce.spawn)(t,r,{env:process.env});const c=setTimeout((()=>{e.abort()}),Se);a.on("close",(()=>{clearTimeout(c);i()}));a.on("error",(()=>{clearTimeout(c);o()}));let l=Promise.resolve();const handler=t=>{l=new Promise((r=>Oe(void 0,void 0,void 0,(function*(){yield l;e.write(t.toString()).finally(r)}))))};(s!==undefined||s===n)&&a.stdout.on("data",handler);(n!==undefined||s===n)&&a.stderr.on("data",handler)}))),((e,t)=>Oe(void 0,void 0,void 0,(function*(){yield t.write(String(e));t.abort()}))))}catch(t){return e.text(t.message,500)}}))));const Pe=Number(process.env["PORT"])||3e3;serve({fetch:_e.fetch.bind(_e),port:Pe});
//# sourceMappingURL=index.js.map