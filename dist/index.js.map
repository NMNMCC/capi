{"version":3,"file":"index.js","names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","threw","__webpack_modules__","getProto","Object","getPrototypeOf","obj","leafPrototypes","t","value","mode","this","__esModule","then","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","d","definition","o","defineProperty","enumerable","get","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","uintDecode","num","buf","ArrayBuffer","arr","Uint8Array","acc","i","globalScope","globalThis","configurable","__GLOBALTHIS__","self","window","global","canonicalizeAlgorithm","algorithm","test","TypeError","hmacDigest","message","external_node_crypto_namespaceObject_0","createHmac","hmac","external_node_crypto_namespaceObject","Buffer","from","update","digest","Error","ALPHABET","base32Decode","str","replace","end","length","substring","toUpperCase","bits","index","idx","base32Encode","hexDecode","parseInt","hexEncode","hex","toString","latin1Decode","charCodeAt","latin1Encode","String","fromCharCode","ENCODER","TextEncoder","DECODER","TextDecoder","utf8Decode","encode","utf8Encode","decode","randomBytes","size","crypto","getRandomValues","Secret","fromLatin1","buffer","fromUTF8","fromBase32","fromHex","bytes","latin1","writable","utf8","base32","constructor","timingSafeEqual","a","b","out","HOTP","defaults","issuer","label","issuerInLabel","digits","counter","generate","secret","offset","byteLength","otp","padStart","validate","token","delta","check","generatedToken","e","encodeURIComponent","TOTP","period","timestamp","Date","now","Math","floor","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","URI","parse","uri","uriGroups","match","_","Array","isArray","URIError","uriType","toLowerCase","uriLabel","split","map","decodeURIComponent","uriParams","reduce","cur","pairArr","pairKey","pairVal","pairAcc","OTP","config","stringify","version","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","rejected","result","done","apply","_a","_b","ALLOWED_EXECUTABLES","process","env","TIMEOUT","Number","SECRET","tokens","Set","server","hono_Hono","ctx","text","code","req","param","totp","randomUUID","add","setTimeout","delete","exec","includes","args","url","slice","arg","stdout","stderr","query","has","streamText","stream","child","external_node_child_process_namespaceObject","spawn","timeout","abort","on","clearTimeout","last","handler","data","write","finally","err","port","serve","fetch","bind"],"sources":["../webpack/bootstrap","../webpack/runtime/create fake namespace object","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../node_modules/.pnpm/otpauth@9.3.6/node_modules/otpauth/dist/otpauth.node.mjs","../src/index.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//! otpauth 9.3.6 | (c) Héctor Molinero Fernández | MIT | https://github.com/hectorm/otpauth\n/// <reference types=\"./otpauth.d.ts\" />\n// @ts-nocheck\nimport * as crypto from 'node:crypto';\n\n/**\n * Converts an integer to an Uint8Array.\n * @param {number} num Integer.\n * @returns {Uint8Array} Uint8Array.\n */ const uintDecode = (num)=>{\n    const buf = new ArrayBuffer(8);\n    const arr = new Uint8Array(buf);\n    let acc = num;\n    for(let i = 7; i >= 0; i--){\n        if (acc === 0) break;\n        arr[i] = acc & 255;\n        acc -= arr[i];\n        acc /= 256;\n    }\n    return arr;\n};\n\n/**\n * \"globalThis\" ponyfill.\n * @see [A horrifying globalThis polyfill in universal JavaScript](https://mathiasbynens.be/notes/globalthis)\n * @type {Object.<string, *>}\n */ const globalScope = (()=>{\n    if (typeof globalThis === \"object\") return globalThis;\n    else {\n        Object.defineProperty(Object.prototype, \"__GLOBALTHIS__\", {\n            get () {\n                return this;\n            },\n            configurable: true\n        });\n        try {\n            // @ts-expect-error\n            // eslint-disable-next-line no-undef\n            if (typeof __GLOBALTHIS__ !== \"undefined\") return __GLOBALTHIS__;\n        } finally{\n            // @ts-expect-error\n            delete Object.prototype.__GLOBALTHIS__;\n        }\n    }\n    // Still unable to determine \"globalThis\", fall back to a naive method.\n    if (typeof self !== \"undefined\") return self;\n    else if (typeof window !== \"undefined\") return window;\n    else if (typeof global !== \"undefined\") return global;\n    return undefined;\n})();\n\n/**\n * Canonicalizes a hash algorithm name.\n * @param {string} algorithm Hash algorithm name.\n * @returns {\"SHA1\"|\"SHA224\"|\"SHA256\"|\"SHA384\"|\"SHA512\"|\"SHA3-224\"|\"SHA3-256\"|\"SHA3-384\"|\"SHA3-512\"} Canonicalized hash algorithm name.\n */ const canonicalizeAlgorithm = (algorithm)=>{\n    switch(true){\n        case /^(?:SHA-?1|SSL3-SHA1)$/i.test(algorithm):\n            return \"SHA1\";\n        case /^SHA(?:2?-)?224$/i.test(algorithm):\n            return \"SHA224\";\n        case /^SHA(?:2?-)?256$/i.test(algorithm):\n            return \"SHA256\";\n        case /^SHA(?:2?-)?384$/i.test(algorithm):\n            return \"SHA384\";\n        case /^SHA(?:2?-)?512$/i.test(algorithm):\n            return \"SHA512\";\n        case /^SHA3-224$/i.test(algorithm):\n            return \"SHA3-224\";\n        case /^SHA3-256$/i.test(algorithm):\n            return \"SHA3-256\";\n        case /^SHA3-384$/i.test(algorithm):\n            return \"SHA3-384\";\n        case /^SHA3-512$/i.test(algorithm):\n            return \"SHA3-512\";\n        default:\n            throw new TypeError(`Unknown hash algorithm: ${algorithm}`);\n    }\n};\n/**\n * Calculates an HMAC digest.\n * @param {string} algorithm Algorithm.\n * @param {Uint8Array} key Key.\n * @param {Uint8Array} message Message.\n * @returns {Uint8Array} Digest.\n */ const hmacDigest = (algorithm, key, message)=>{\n    if (crypto?.createHmac) {\n        const hmac = crypto.createHmac(algorithm, globalScope.Buffer.from(key));\n        hmac.update(globalScope.Buffer.from(message));\n        return hmac.digest();\n    } else {\n        throw new Error(\"Missing HMAC function\");\n    }\n};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */ const ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n/**\n * Converts a base32 string to an Uint8Array (RFC 4648).\n * @see [LinusU/base32-decode](https://github.com/LinusU/base32-decode)\n * @param {string} str Base32 string.\n * @returns {Uint8Array} Uint8Array.\n */ const base32Decode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    // Canonicalize to all upper case and remove padding if it exists.\n    let end = str.length;\n    while(str[end - 1] === \"=\")--end;\n    str = (end < str.length ? str.substring(0, end) : str).toUpperCase();\n    const buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n    const arr = new Uint8Array(buf);\n    let bits = 0;\n    let value = 0;\n    let index = 0;\n    for(let i = 0; i < str.length; i++){\n        const idx = ALPHABET.indexOf(str[i]);\n        if (idx === -1) throw new TypeError(`Invalid character found: ${str[i]}`);\n        value = value << 5 | idx;\n        bits += 5;\n        if (bits >= 8) {\n            bits -= 8;\n            arr[index++] = value >>> bits;\n        }\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a base32 string (RFC 4648).\n * @see [LinusU/base32-encode](https://github.com/LinusU/base32-encode)\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Base32 string.\n */ const base32Encode = (arr)=>{\n    let bits = 0;\n    let value = 0;\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        value = value << 8 | arr[i];\n        bits += 8;\n        while(bits >= 5){\n            str += ALPHABET[value >>> bits - 5 & 31];\n            bits -= 5;\n        }\n    }\n    if (bits > 0) {\n        str += ALPHABET[value << 5 - bits & 31];\n    }\n    return str;\n};\n\n/**\n * Converts a hexadecimal string to an Uint8Array.\n * @param {string} str Hexadecimal string.\n * @returns {Uint8Array} Uint8Array.\n */ const hexDecode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    const buf = new ArrayBuffer(str.length / 2);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i += 2){\n        arr[i / 2] = parseInt(str.substring(i, i + 2), 16);\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a hexadecimal string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Hexadecimal string.\n */ const hexEncode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        const hex = arr[i].toString(16);\n        if (hex.length === 1) str += \"0\";\n        str += hex;\n    }\n    return str.toUpperCase();\n};\n\n/**\n * Converts a Latin-1 string to an Uint8Array.\n * @param {string} str Latin-1 string.\n * @returns {Uint8Array} Uint8Array.\n */ const latin1Decode = (str)=>{\n    const buf = new ArrayBuffer(str.length);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i++){\n        arr[i] = str.charCodeAt(i) & 0xff;\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a Latin-1 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Latin-1 string.\n */ const latin1Encode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        str += String.fromCharCode(arr[i]);\n    }\n    return str;\n};\n\n/**\n * TextEncoder instance.\n * @type {TextEncoder|null}\n */ const ENCODER = globalScope.TextEncoder ? new globalScope.TextEncoder() : null;\n/**\n * TextDecoder instance.\n * @type {TextDecoder|null}\n */ const DECODER = globalScope.TextDecoder ? new globalScope.TextDecoder() : null;\n/**\n * Converts an UTF-8 string to an Uint8Array.\n * @param {string} str String.\n * @returns {Uint8Array} Uint8Array.\n */ const utf8Decode = (str)=>{\n    if (!ENCODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return ENCODER.encode(str);\n};\n/**\n * Converts an Uint8Array to an UTF-8 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} String.\n */ const utf8Encode = (arr)=>{\n    if (!DECODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return DECODER.decode(arr);\n};\n\n/**\n * Returns random bytes.\n * @param {number} size Size.\n * @returns {Uint8Array} Random bytes.\n */ const randomBytes = (size)=>{\n    if (crypto?.randomBytes) {\n        return crypto.randomBytes(size);\n    } else if (globalScope.crypto?.getRandomValues) {\n        return globalScope.crypto.getRandomValues(new Uint8Array(size));\n    } else {\n        throw new Error(\"Cryptography API not available\");\n    }\n};\n\n/**\n * OTP secret key.\n */ class Secret {\n    /**\n   * Converts a Latin-1 string to a Secret object.\n   * @param {string} str Latin-1 string.\n   * @returns {Secret} Secret object.\n   */ static fromLatin1(str) {\n        return new Secret({\n            buffer: latin1Decode(str).buffer\n        });\n    }\n    /**\n   * Converts an UTF-8 string to a Secret object.\n   * @param {string} str UTF-8 string.\n   * @returns {Secret} Secret object.\n   */ static fromUTF8(str) {\n        return new Secret({\n            buffer: utf8Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a base32 string to a Secret object.\n   * @param {string} str Base32 string.\n   * @returns {Secret} Secret object.\n   */ static fromBase32(str) {\n        return new Secret({\n            buffer: base32Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a hexadecimal string to a Secret object.\n   * @param {string} str Hexadecimal string.\n   * @returns {Secret} Secret object.\n   */ static fromHex(str) {\n        return new Secret({\n            buffer: hexDecode(str).buffer\n        });\n    }\n    /**\n   * Secret key buffer.\n   * @deprecated For backward compatibility, the \"bytes\" property should be used instead.\n   * @type {ArrayBufferLike}\n   */ get buffer() {\n        return this.bytes.buffer;\n    }\n    /**\n   * Latin-1 string representation of secret key.\n   * @type {string}\n   */ get latin1() {\n        Object.defineProperty(this, \"latin1\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: latin1Encode(this.bytes)\n        });\n        return this.latin1;\n    }\n    /**\n   * UTF-8 string representation of secret key.\n   * @type {string}\n   */ get utf8() {\n        Object.defineProperty(this, \"utf8\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: utf8Encode(this.bytes)\n        });\n        return this.utf8;\n    }\n    /**\n   * Base32 string representation of secret key.\n   * @type {string}\n   */ get base32() {\n        Object.defineProperty(this, \"base32\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: base32Encode(this.bytes)\n        });\n        return this.base32;\n    }\n    /**\n   * Hexadecimal string representation of secret key.\n   * @type {string}\n   */ get hex() {\n        Object.defineProperty(this, \"hex\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: hexEncode(this.bytes)\n        });\n        return this.hex;\n    }\n    /**\n   * Creates a secret key object.\n   * @param {Object} [config] Configuration options.\n   * @param {ArrayBufferLike} [config.buffer] Secret key buffer.\n   * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n   */ constructor({ buffer, size = 20 } = {}){\n        /**\n     * Secret key.\n     * @type {Uint8Array}\n     * @readonly\n     */ this.bytes = typeof buffer === \"undefined\" ? randomBytes(size) : new Uint8Array(buffer);\n        // Prevent the \"bytes\" property from being modified.\n        Object.defineProperty(this, \"bytes\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: this.bytes\n        });\n    }\n}\n\n/**\n * Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values.\n * @param {string} a String a.\n * @param {string} b String b.\n * @returns {boolean} Equality result.\n */ const timingSafeEqual = (a, b)=>{\n    if (crypto?.timingSafeEqual) {\n        return crypto.timingSafeEqual(globalScope.Buffer.from(a), globalScope.Buffer.from(b));\n    } else {\n        if (a.length !== b.length) {\n            throw new TypeError(\"Input strings must have the same length\");\n        }\n        let i = -1;\n        let out = 0;\n        while(++i < a.length){\n            out |= a.charCodeAt(i) ^ b.charCodeAt(i);\n        }\n        return out === 0;\n    }\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm.\n * @see [RFC 4226](https://datatracker.ietf.org/doc/html/rfc4226)\n */ class HOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   counter: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            counter: 0,\n            window: 1\n        };\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter }) {\n        const digest = hmacDigest(algorithm, secret.bytes, uintDecode(counter));\n        const offset = digest[digest.byteLength - 1] & 15;\n        const otp = ((digest[offset] & 127) << 24 | (digest[offset + 1] & 255) << 16 | (digest[offset + 2] & 255) << 8 | digest[offset + 3] & 255) % 10 ** digits;\n        return otp.toString().padStart(digits, \"0\");\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.counter=this.counter++] Counter value.\n   * @returns {string} Token.\n   */ generate({ counter = this.counter++ } = {}) {\n        return HOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter\n        });\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter, window = HOTP.defaults.window }) {\n        // Return early if the token length does not match the digit number.\n        if (token.length !== digits) return null;\n        let delta = null;\n        const check = (/** @type {number} */ i)=>{\n            const generatedToken = HOTP.generate({\n                secret,\n                algorithm,\n                digits,\n                counter: i\n            });\n            if (timingSafeEqual(token, generatedToken)) {\n                delta = i - counter;\n            }\n        };\n        check(counter);\n        for(let i = 1; i <= window && delta === null; ++i){\n            check(counter - i);\n            if (delta !== null) break;\n            check(counter + i);\n            if (delta !== null) break;\n        }\n        return delta;\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.counter=this.counter] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, counter = this.counter, window }) {\n        return HOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://hotp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `counter=${e(this.counter)}`;\n    }\n    /**\n   * Creates an HOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Initial counter value.\n   */ constructor({ issuer = HOTP.defaults.issuer, label = HOTP.defaults.label, issuerInLabel = HOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Initial counter value.\n     * @type {number}\n     */ this.counter = counter;\n    }\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm.\n * @see [RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238)\n */ class TOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   period: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            period: 30,\n            window: 1\n        };\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now() }) {\n        return HOTP.generate({\n            secret,\n            algorithm,\n            digits,\n            counter: Math.floor(timestamp / 1000 / period)\n        });\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ generate({ timestamp = Date.now() } = {}) {\n        return TOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now(), window }) {\n        return HOTP.validate({\n            token,\n            secret,\n            algorithm,\n            digits,\n            counter: Math.floor(timestamp / 1000 / period),\n            window\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, timestamp, window }) {\n        return TOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://totp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `period=${e(this.period)}`;\n    }\n    /**\n   * Creates a TOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   */ constructor({ issuer = TOTP.defaults.issuer, label = TOTP.defaults.label, issuerInLabel = TOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = TOTP.defaults.algorithm, digits = TOTP.defaults.digits, period = TOTP.defaults.period } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Token time-step duration.\n     * @type {number}\n     */ this.period = period;\n    }\n}\n\n/**\n * Key URI regex (otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS).\n * @type {RegExp}\n */ const OTPURI_REGEX = /^otpauth:\\/\\/([ht]otp)\\/(.+)\\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;\n/**\n * RFC 4648 base32 alphabet with pad.\n * @type {RegExp}\n */ const SECRET_REGEX = /^[2-7A-Z]+=*$/i;\n/**\n * Regex for supported algorithms.\n * @type {RegExp}\n */ const ALGORITHM_REGEX = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;\n/**\n * Integer regex.\n * @type {RegExp}\n */ const INTEGER_REGEX = /^[+-]?\\d+$/;\n/**\n * Positive integer regex.\n * @type {RegExp}\n */ const POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n/**\n * HOTP/TOTP object/string conversion.\n * @see [Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)\n */ class URI {\n    /**\n   * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n   * @param {string} uri Google Authenticator Key URI.\n   * @returns {HOTP|TOTP} HOTP/TOTP object.\n   */ static parse(uri) {\n        let uriGroups;\n        try {\n            uriGroups = uri.match(OTPURI_REGEX);\n        // eslint-disable-next-line no-unused-vars\n        } catch (_) {\n        /* Handled below */ }\n        if (!Array.isArray(uriGroups)) {\n            throw new URIError(\"Invalid URI format\");\n        }\n        // Extract URI groups.\n        const uriType = uriGroups[1].toLowerCase();\n        const uriLabel = uriGroups[2].split(/(?::|%3A) *(.+)/i, 2).map(decodeURIComponent);\n        /** @type {Object.<string, string>} */ const uriParams = uriGroups[3].split(\"&\").reduce((acc, cur)=>{\n            const pairArr = cur.split(/=(.*)/, 2).map(decodeURIComponent);\n            const pairKey = pairArr[0].toLowerCase();\n            const pairVal = pairArr[1];\n            /** @type {Object.<string, string>} */ const pairAcc = acc;\n            pairAcc[pairKey] = pairVal;\n            return pairAcc;\n        }, {});\n        // 'OTP' will be instantiated with 'config' argument.\n        let OTP;\n        const config = {};\n        if (uriType === \"hotp\") {\n            OTP = HOTP;\n            // Counter: required\n            if (typeof uriParams.counter !== \"undefined\" && INTEGER_REGEX.test(uriParams.counter)) {\n                config.counter = parseInt(uriParams.counter, 10);\n            } else {\n                throw new TypeError(\"Missing or invalid 'counter' parameter\");\n            }\n        } else if (uriType === \"totp\") {\n            OTP = TOTP;\n            // Period: optional\n            if (typeof uriParams.period !== \"undefined\") {\n                if (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n                    config.period = parseInt(uriParams.period, 10);\n                } else {\n                    throw new TypeError(\"Invalid 'period' parameter\");\n                }\n            }\n        } else {\n            throw new TypeError(\"Unknown OTP type\");\n        }\n        // Label: required\n        // Issuer: optional\n        if (typeof uriParams.issuer !== \"undefined\") {\n            config.issuer = uriParams.issuer;\n        }\n        if (uriLabel.length === 2) {\n            config.label = uriLabel[1];\n            if (typeof config.issuer === \"undefined\" || config.issuer === \"\") {\n                config.issuer = uriLabel[0];\n            } else if (uriLabel[0] === \"\") {\n                config.issuerInLabel = false;\n            }\n        } else {\n            config.label = uriLabel[0];\n            if (typeof config.issuer !== \"undefined\" && config.issuer !== \"\") {\n                config.issuerInLabel = false;\n            }\n        }\n        // Secret: required\n        if (typeof uriParams.secret !== \"undefined\" && SECRET_REGEX.test(uriParams.secret)) {\n            config.secret = uriParams.secret;\n        } else {\n            throw new TypeError(\"Missing or invalid 'secret' parameter\");\n        }\n        // Algorithm: optional\n        if (typeof uriParams.algorithm !== \"undefined\") {\n            if (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n                config.algorithm = uriParams.algorithm;\n            } else {\n                throw new TypeError(\"Invalid 'algorithm' parameter\");\n            }\n        }\n        // Digits: optional\n        if (typeof uriParams.digits !== \"undefined\") {\n            if (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n                config.digits = parseInt(uriParams.digits, 10);\n            } else {\n                throw new TypeError(\"Invalid 'digits' parameter\");\n            }\n        }\n        return new OTP(config);\n    }\n    /**\n   * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n   * @param {HOTP|TOTP} otp HOTP/TOTP object.\n   * @returns {string} Google Authenticator Key URI.\n   */ static stringify(otp) {\n        if (otp instanceof HOTP || otp instanceof TOTP) {\n            return otp.toString();\n        }\n        throw new TypeError(\"Invalid 'HOTP/TOTP' object\");\n    }\n}\n\n/**\n * Library version.\n * @type {string}\n */ const version = \"9.3.6\";\n\nexport { HOTP, Secret, TOTP, URI, version };\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a, _b;\nimport { serve } from \"@hono/node-server\";\nimport { Hono } from \"hono\";\nimport { streamText } from \"hono/streaming\";\nimport { spawn } from \"node:child_process\";\nimport { randomUUID } from \"node:crypto\";\nimport * as OTPAuth from \"otpauth\";\nconst ALLOWED_EXECUTABLES = (_b = (_a = process.env[\"ALLOWED_EXECUTABLES\"]) === null || _a === void 0 ? void 0 : _a.split(\",\")) !== null && _b !== void 0 ? _b : [];\nconst TIMEOUT = Number(process.env[\"TIMEOUT\"]) || 10000;\nconst SECRET = process.env[\"SECRET\"];\nconst tokens = new Set();\nconst server = new Hono()\n    .get(\"/health\", (ctx) => __awaiter(void 0, void 0, void 0, function* () { return ctx.text(\"OK\"); }))\n    .get(\"/auth/:code?\", (ctx) => __awaiter(void 0, void 0, void 0, function* () {\n    const { code } = ctx.req.param();\n    if (!SECRET || !code) {\n        const secret = new OTPAuth.Secret().base32;\n        return ctx.text(secret);\n    }\n    const totp = new OTPAuth.TOTP({ secret: SECRET });\n    if (!totp.validate({ token: code })) {\n        return ctx.text(\"Invalid code\", 403);\n    }\n    const token = randomUUID();\n    tokens.add(token);\n    setTimeout(() => tokens.delete(token), 1800000);\n    return ctx.text(token);\n}))\n    .get(\"/:exec/*\", (ctx) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const { exec } = ctx.req.param();\n        if (!ALLOWED_EXECUTABLES.includes(exec)) {\n            return ctx.text(\"Not allowed\", 403);\n        }\n        const args = ctx.req.url\n            .split(\"/\")\n            .slice(4)\n            .map((arg) => decodeURIComponent(arg));\n        const { stdout, stderr, token } = ctx.req.query();\n        if (token && !tokens.has(token)) {\n            return ctx.text(\"Invalid token\", 403);\n        }\n        return streamText(ctx, (stream) => new Promise((resolve, reject) => {\n            const child = spawn(exec, args, {\n                env: process.env,\n            });\n            const timeout = setTimeout(() => {\n                stream.abort();\n            }, TIMEOUT);\n            child.on(\"close\", () => {\n                clearTimeout(timeout);\n                resolve();\n            });\n            child.on(\"error\", () => {\n                clearTimeout(timeout);\n                reject();\n            });\n            let last = Promise.resolve();\n            const handler = (data) => {\n                last = new Promise((resolve) => __awaiter(void 0, void 0, void 0, function* () {\n                    yield last;\n                    stream.write(data.toString()).finally(resolve);\n                }));\n            };\n            (stdout !== undefined || stdout === stderr) &&\n                child.stdout.on(\"data\", handler);\n            (stderr !== undefined || stdout === stderr) &&\n                child.stderr.on(\"data\", handler);\n        }), (err, stream) => __awaiter(void 0, void 0, void 0, function* () {\n            yield stream.write(String(err));\n            stream.abort();\n        }));\n    }\n    catch (e) {\n        return ctx.text(e.message, 500);\n    }\n}));\nconst port = Number(process.env[\"PORT\"]) || 3000;\nserve({\n    fetch: server.fetch.bind(server),\n    port: port,\n});\n"],"mappings":"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","ignoreList":[]}